---
layout: post
title: The concept of ID in shaders
date: 2021-09-02 09:59
language: ru
---

Расскажу про концепцию идентификатора в шейдерах и покажу, на что она способна.

Идея простая:

0. Задаём начальный id. Например, пусть будет равен единице.
1. делим изображение на части по некоторому критерию, зависимому от id, полученному на предыдущем шаге. Получаем новые идентификаторы.
3. Повторяем пункт 1 несколько раз, каждый раз увеличивая количиство возможных id и тем самым усложняя картинку.
4. Используем id для расчёта цвета, текстуры, чего угодно.

<!--
Начнём постепенно.

```glsl
// получаем нормализованные координаты
vec2 uv = FC.xy/r;

// назначаем уникальные идентификаторы от 0 до 1, они зависят от горизонтального положения пикселя
float id=floor(uv.x*3.)/3.;

// назначаем каждому пикселю цвет, зависящий от id
// тут я использую пару функций, предоставляемых редактором, код можно посмотреть в репозитории https://github.com/doxas/twigl
o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```

![](/assets/2021-09-02-11-15-28.png)
https://bit.ly/3gVo0CL

```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;

// разделим пиксели по другому критерию, зависящему от предыдущего значения id
id=floor(uv.y*3.+id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```
![](/assets/2021-09-02-11-19-29.png)
https://bit.ly/3jEmcQw


```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;
id=floor(uv.y*3.+id)/3.;

// продолжаем делить пространство
id=floor(uv.x*18.*id)/3.;
id=floor(uv.y*9.*id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```
https://bit.ly/3yEjP4m
![](/assets/2021-09-02-11-24-23.png)

Стало очень шумно, хочется сгруппировать некоторые крошечные сегменты. Для этого вычислим яркость группы в середине процесса деления:

```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;
id=floor(uv.y*3.+id)/3.;

// используем айди для вычисления яркости группы
float shade = fsnoise(vec2(id));

id=floor(uv.x*18.*id)/3.;
id=floor(uv.y*9.*id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.)*shade;
```
https://bit.ly/3DPoBjp
![](/assets/2021-09-02-11-30-18.png)

О, нет. Оказалось, что айдишники групп второго уровня совпадают внутри групп первого уровня. Это видно по горизонтальным полоскам, имеющим одинаковую яркость.

Хочется сделать айдишник (и яркость цвета) уникальным для каждой группы. Тут есть два пути: аккуратный и хаотичный.-->

Определять айдишник можно аккуратно или хаотично.

### Аккуратный способ сегментации

Допустим, мы каждый раз делим картинку на три части. Тогда при первом делении сделаем айдишники частей 0, 1/3, 2/3. При втором делении каждой части натрое, прибавим к уже найденным айдишникам уменьшенные значения: 0, 1/9, 2/9.
Каждое следующее деление должно менять айдишник с меньшим и меньшим шагом.

Весь интервал id должен укладываться в один шаг дискретизации предыдущего деления.

Так каждый из айдишников будет уникальным, ура. Попробуем в коде:

```
vec2 uv = FC.xy/r;

float id=0., k=1.;

uv=fract(uv)*3.;

id+=floor(uv.x)/3.; // делим на три столбца
k/=3.;
id+=k*floor(uv.y)/3.; // делим на три строки
k/=3.;

uv=fract(uv)*3.;

id+=k*floor(uv.x)/3.; // делим на три столбца
k/=3.;
id+=k*floor(uv.y)/3.;  // делим на три строки
k/=3.;

o+=id;
```
![](/assets/2021-09-02-12-03-24.png)

Мы видим, что каждый сегмент имеет свой уникальный цвет, но для этого приходится использовать мультипликатор k, что не всегда удобно. Часто бывает достаточно хаотического подхода.

### Хаотический способ сегментации

Тупо рандомим айдишник, добавляя в seed для рандома предыдущее значение айдишника. Видим, что сетка получается хаотичной,  может у каких-то регионов айдишники и совпадут, но вероятность маленькая.

```glsl
#define rnd(x) fsnoise(vec2(x))
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.+id);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

o+=id;
```
![](/assets/2021-09-02-12-10-49.png)

## Изменчивость сегментов

Пристегните ремни. Сейчас самое крутое. Можно сделать настройки последующих разбиений зависимыми от текущего айдишника. Буум!

Например, тут число разбиений может варьировать в зависимости от айди:

```glsl
#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);  // делим на три столбца
id=rnd(floor(uv.y)/3.+id);  // делим на три строки

uv=fract(uv)*3.;

//                 ↓ чем меньше, тем гуще
id=rnd(floor(uv.x/id)/3.+id);  // делим на три столбца
id=rnd(floor(uv.y/id)/3.+id);  // делим на три строки

o+=id;
```
![](/assets/2021-09-03-10-23-52.png)

Можно повторять и повторять разбиение сколько угодно. Или лучше добавить цикл, чтобы не копипастить.

```glsl
#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i<3;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
```
![](/assets/2021-09-03-10-28-11.png)

Если добавить увеличить число повторов до 5, останется один мусор:

![](/assets/2021-09-03-10-29-17.png)

Но ведь мы можем сделать число повторов цикла также зависимым от id!

```glsl
#define rnd(x) fsnoise(vec2(x)+.1)
vec2 uv = FC.xy/r;

float id=1.;

for(int i=0;i<5;i++){
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
  if(i>0 && id<.5) break;
}

o+=id;
```
![](/assets/2021-09-03-10-31-37.png)

Картинка потемнела, это что-то вроде ошибки выжившего. Мы вылетаем из цикла, когда айдишник меньше .5, а у таких цвет получается тёмным. Это исправляется заменой условия id<.5 на rnd(id)<.5

![](/assets/2021-09-03-10-33-51.png)

А теперь, когда приём освоен, можно идти и веселиться по-полной.

```glsl
#define rnd(x) fsnoise(vec2(x)+.1)
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

vec2 uv = (FC.xy*2.-r)/r.x;

float id=floor(length(uv)*8.)+1.;

for(int i=0;i<5;i++){
  if(i>0 && rnd(id)<.5) break;
  uv*=rot(PI/4.+t*(rnd(id)-.5));
  uv=fract(uv)*3.;
  id=rnd(floor(uv.x/id)/3.+id);
  id=rnd(floor(uv.y/id)/3.+id);
}

o+=id;
```

![](/assets/2021-09-03-10-49-32.png)
Посмотрите ссылку, оно ещё и крутится! Скорость вращения, конечно же, тоже зависит от айдишников. https://bit.ly/3BE99o9