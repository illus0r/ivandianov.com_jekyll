---
layout: post
title: The concept of ID in shaders
date: 2021-09-02 09:59
---

Расскажу про концепцию идентификатора и покажу, на что она способна.

Идея простая:

1. делим изображение на части по некоторому признаку и каждой части назначаем свой идентификатор.
2. Повторяем деление по другому критерию, зависимому от id, полученному на предыдущем шаге. Получаем новые идентификаторы.
3. Повторяем сколько угодно, усложняя картинку до невозможности.
4. Используем id для расчёта цвета, текстуры, чего угодно.

Начнём постепенно.

```glsl
// получаем нормализованные координаты
vec2 uv = FC.xy/r;

// назначаем уникальные идентификаторы от 0 до 1, они зависят от горизонтального положения пикселя
float id=floor(uv.x*3.)/3.;

// назначаем каждому пикселю цвет, зависящий от id
// тут я использую пару функций, предоставляемых редактором, код можно посмотреть в репозитории https://github.com/doxas/twigl
o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```

![](/assets/2021-09-02-11-15-28.png)
https://bit.ly/3gVo0CL

```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;

// разделим пиксели по другому критерию, зависящему от предыдущего значения id
id=floor(uv.y*3.+id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```
![](/assets/2021-09-02-11-19-29.png)
https://bit.ly/3jEmcQw


```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;
id=floor(uv.y*3.+id)/3.;

// продолжаем делить пространство
id=floor(uv.x*18.*id)/3.;
id=floor(uv.y*9.*id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.);
```
https://bit.ly/3yEjP4m
![](/assets/2021-09-02-11-24-23.png)

Стало очень шумно, хочется сгруппировать некоторые крошечные сегменты. Для этого вычислим яркость группы в середине процесса деления:

```glsl
vec2 uv = FC.xy/r;

float id;
id=floor(uv.x*3.)/3.;
id=floor(uv.y*3.+id)/3.;

// используем айди для вычисления яркости группы
float shade = fsnoise(vec2(id));

id=floor(uv.x*18.*id)/3.;
id=floor(uv.y*9.*id)/3.;

o.rgb=hsv(fsnoise(vec2(id)),1.,1.)*shade;
```
https://bit.ly/3DPoBjp
![](/assets/2021-09-02-11-30-18.png)

О, нет. Оказалось, что айдишники групп второго уровня совпадают внутри групп первого уровня. Это видно по горизонтальным полоскам, имеющим одинаковую яркость.

Хочется сделать айдишник (и яркость цвета) уникальным для каждой группы. Тут есть два пути: аккуратный и хаотичный.

### Аккуратный способ сегментации

Каждое следующее деление должно менять айдишник с меньшей дискретизцией. Весь интервал id должен укладываться в один шаг дискретизации предыдущего деления. Например, если первое деление делит id на две ступеньки {0, .5}, то второе деление на 2 ступеньки даст нам множество {0, .25, .5, .75}. Айдишники уникальные, ура. Попробуем в коде:

```
vec2 uv = FC.xy/r;

float id=0., k=1.;

uv=fract(uv)*3.;

id+=floor(uv.x)/3.;
k/=3.;
id+=k*floor(uv.y)/3.;
k/=3.;

uv=fract(uv)*3.;

id+=k*floor(uv.x)/3.;
k/=3.;
id+=k*floor(uv.y)/3.;
k/=3.;

o+=id;
```
![](/assets/2021-09-02-12-03-24.png)

Мы видим, что каждый сегмент имеет свой уникальный цвет, но для этого приходится использовать мультипликатор k, что не всегда удобно. Часто бывает достаточно хаотического подхода.

### Хаотический способ сегментации

Тупо рандомим айдишник, добавляя в seed для рандома предыдущее значение айдишника. Видим, что сетка получается хаотичной,  может у каких-то регионов айдишники и совпадут, но вероятность маленькая.

```glsl
#define rnd(x) fsnoise(vec2(x))
vec2 uv = FC.xy/r;

float id=0.;

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.);
id=rnd(floor(uv.y)/3.+id);

uv=fract(uv)*3.;

id=rnd(floor(uv.x)/3.+id);
id=rnd(floor(uv.y)/3.+id);

o+=id;
```
![](/assets/2021-09-02-12-10-49.png)

